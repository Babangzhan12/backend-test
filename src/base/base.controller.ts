import { NextFunction, Request, Response } from 'express';
import { Model , ModelStatic, FindOptions, Transaction } from 'sequelize';
import { jsonBadRequest, jsonError, jsonForbidden, jsonNotFound, jsonSuccess, jsonSuccessPaginated } from '../utils/responses';
import { flexiblePaginate } from '../utils/paginate';
import { MakeNullishOptional } from 'sequelize/types/utils';
import { AuthUser } from '../middleware/jwt.middleware';
import sequelize from '../database/database';
import { Role } from '../model/index.model';


interface BaseControllerOptions {
  searchableFields?: string[];
}

export interface RequestWithUser extends Request {
user?: AuthUser; 
}

export class BaseController<T extends Model> {

  constructor(
    protected model: ModelStatic<T>,
    protected options?: BaseControllerOptions
  ) {}

  protected get allowedFields(): string[] {
    const raw = (this.model as any).rawAttributes;
    return raw
      ? Object.entries(raw)
          .filter(([_, attr]) => !(attr as any)._autoGenerated)
          .map(([key]) => key)
      : [];
  }


  protected getModelName(): string {
    return this.model.name;
  }

  protected getAllOptions(): FindOptions {
    return { paranoid: true}; 
  }

  protected getBySelectOptions(filter: any = {}): FindOptions {
    return {
      where: { ...filter },
    }; 
  }

  protected getByIdOptions(id: string, req: Request): FindOptions {
    return {}; 
  }

  protected getPaginateOptions(req: Request): any {
    return {}; 
  }

  protected getCreateOptions(data: any, includeOptions: any[], fields: string[] | null): FindOptions {
    return {
      ...(includeOptions.length > 0 && { include: includeOptions }),
      ...(fields && fields.length > 0 && { attributes: fields }),
    };
  }

  protected parseProjection(data: any) {
    const includes = data.__includes || [];
    const fields = data.__fields || null;
  
    delete data.__includes;
    delete data.__fields;
  
    const includeOptions = includes.map((name: string) => {
      const assoc = this.model.associations[name];
      if (!assoc) return null;
  
      return { association: name };
    }).filter(Boolean);
  
    return { data, includeOptions, fields };
  }


  protected async createWithNested(
    model: any,
    data: any,
    transaction: any,
    parentForeignKeyMap: Record<string, any> = {}
  ): Promise<any> {
    const associations = model.associations || {};
    const flatData: Record<string, any> = {};
    const nestedData: Record<string, any[]> = {};

    for (const [key, value] of Object.entries(data)) {
      if (associations[key]) {
        nestedData[key] = value as any;
      } else {
        flatData[key] = value;
      }
    }
  
    for (const [key, value] of Object.entries(parentForeignKeyMap)) {
      if (!flatData[key]) {
        flatData[key] = value;
      }
    }
  
    for (const assoc of Object.values(model.associations) as any) {
      if (assoc.associationType === 'BelongsTo') {
        const fk = assoc.foreignKey as string;
        const sourceKey = assoc.target['primaryKeyAttribute'];
        const value = (parentForeignKeyMap as any)[sourceKey];
        if (value && !flatData[fk]) {
          flatData[fk] = value;
        }
      }
    }
  
    const created = await model.create(flatData, { transaction });
  
    for (const [assocName, records] of Object.entries(nestedData)) {
      const assoc = associations[assocName];
      const targetModel = assoc.target;
      const foreignKey = assoc.foreignKey as string;
      if (Array.isArray(records)) {
        for (const nestedRecord of records) {
          await this.createWithNested(
            targetModel,
            nestedRecord,
            transaction,
            { [foreignKey]: created[model.primaryKeyAttribute], ...flatData }
          );
        }
      } else {
        const nestedCreated = await this.createWithNested(
          targetModel,
          records,
          transaction
        );
        created[foreignKey] = nestedCreated[targetModel.primaryKeyAttribute];
        await created.save({ transaction });
      }
    }
    
  
    return created;
  }

  protected async fetchWithAllIncludes(instance: any, transaction?: Transaction): Promise<any> {
    const pk = instance[this.model.primaryKeyAttribute];
    return this.model.findByPk(pk, {
      include: Object.values(this.model.associations),
      transaction, 
    });
  }

  protected async applyClientFilter(req: RequestWithUser) {
    const { role, userId } = req.user || {};
  const attributes = Object.keys((this.model as any).rawAttributes || {});

  const hasUserId = attributes.includes("userId");
  const hasRoleId = attributes.includes("roleId");

  if (!hasUserId && !hasRoleId) {
    return {}; 
  }
  switch (role) {
    case 'superadmin':
      return {};
    case 'admin':
       return {
        roleId: await this.getRoleId('customer')
       };
    case 'customer':
       return {userId};
    default:
      return {userId};
  }
  }

  private async getRoleId(name: string) {
    const role = await Role.findOne({ where: { name } });
    return role?.roleId;
}

  protected async beforeCreate(data: any, req: RequestWithUser): Promise<any> {
  return data;
  }

  protected async beforeUpdate(data: any, req: RequestWithUser): Promise<any> {
  return data;
  }

  

  getAllPaginated = async (req: RequestWithUser, res: Response, next:NextFunction): Promise<void> => {
    try {
      const query = req.query as any;
      const filter = query.filter ?? {};

      const clientFilter = await this.applyClientFilter(req);
      const combinedFilter = {
      ...filter,
      ...clientFilter, 
    };
    console.log('combinedFilter', combinedFilter);

    if (!combinedFilter.search || combinedFilter.search.trim() === "") {
      combinedFilter.search = "";
    }

      const defueltOptions = {
        ...this.getAllOptions(),
        paranoid: true 
        };
      console.log('Combined Filter: di sni', defueltOptions);
      const currentPage = filter.page ? parseInt(filter.page) : 1;
      const result = await flexiblePaginate(
        this.model,
        { 
          filter: combinedFilter,
        },
        this.options?.searchableFields ?? [],
        defueltOptions,
      );
       jsonSuccessPaginated(res, result.data, `${this.getModelName()} fetched pagination successfully`, 200, {total: result.total, totalPages: result.totalPages, currentPage: result.currentPage, perPage: result.perPage});
    } catch (error) {
      console.log({error})
      next(error)
    }
  };

  getAll = async (req: RequestWithUser, res: Response, next:NextFunction): Promise<void> => {
    try {
      const whereFilter = await this.applyClientFilter(req);
      console.log('whereFilter', whereFilter)
      const options = this.getAllOptions();
      options.paranoid = true;
      options.where = { 
      ...options.where,
      ...whereFilter,
    };
      const items = await this.model.findAll(options);
       jsonSuccess(res, items, `${this.getModelName()} fetched all successfully`);
    } catch (error) {
       next(error)
    }
  };

  getBySelect = async (req: RequestWithUser, res: Response, next:NextFunction): Promise<void> => {
    try {
      const clientFilter = await this.applyClientFilter(req);
      const options = this.getBySelectOptions(clientFilter);
      options.paranoid = true;
      const items = await this.model.findAll(options);
       jsonSuccess(res, items, `${this.getModelName()} fetched all successfully`);
    } catch (error) {
       next(error)
    }
  };

  getById = async (req: RequestWithUser, res: Response, next:NextFunction): Promise<void> => {
    const { id } = req.params;
    try {
      console.log('req user', req.user)
      const whereFilterRaw  = await this.applyClientFilter(req);
      console.log('whereFilterRaw', whereFilterRaw)
      const whereFilter = Object.fromEntries(
      Object.entries(whereFilterRaw).filter(([_, v]) => v !== undefined)
    );

      const options = this.getByIdOptions(id, req);

      const { include, ...restOptions } = options;

      const finalWhere = {
        [this.model.primaryKeyAttribute]: id,
        ...whereFilter,
      };

      const item = await this.model.findOne({
        where: finalWhere,
        include,
        paranoid: true, 
        ...restOptions,
        logging: console.log,
      });
      if (!item) {
         jsonNotFound(res, `${this.getModelName()} not found`, id);
         return;
      }
       jsonSuccess(res, item, `${this.getModelName()} fetching by id successfully`);
    } catch (error) {
       next(error)
    }
  };

  create = async (req: RequestWithUser, res: Response, next:NextFunction): Promise<void> => {
    const t = await sequelize.transaction();
    try {
      const { role, userId } = req.user || {};
      let { data, includeOptions, fields } = this.parseProjection({ ...req.body });

      if (typeof this.beforeCreate === "function") {
        data = await this.beforeCreate(data, req); 
      }

      if (role === "customer") {
      if ("userId" in data) delete data.userId;
        data.userId = userId; 
    }

      if (role === "admin") {
      if ("roleId" in data) {
        const roleTarget = await Role.findByPk(data.roleId);

        if (!roleTarget) {
          await t.rollback();
           jsonBadRequest(res, "Invalid roleId");
           return;
        }

        if (roleTarget.name !== "customer") {
          await t.rollback();
          jsonForbidden(res, "Admin cannot create admin/superadmin");
          return;
        }
      }
    }

      const invalidFields = Object.keys(data).filter((key) =>
      !this.allowedFields.includes(key) && !this.model.associations[key]
      );

      if (invalidFields.length > 0) {
        return void jsonBadRequest(res, `Invalid field(s): ${invalidFields.join(", ")}`);
      }

      const created = await this.createWithNested(this.model, data, t);

      const defaultOptions = this.getCreateOptions(data, includeOptions, fields);

      const fullItem = await this.model.findByPk(created[this.model.primaryKeyAttribute], {
        include: includeOptions.length ? includeOptions : Object.values(this.model.associations),
        transaction: t,
        ...defaultOptions,
      });


       await t.commit();

       const result = fields
      ? fields.reduce((obj: any, key: string) => {
          obj[key] = (fullItem as any)?.[key];
          return obj;
        }, {})
      : fullItem;

       jsonSuccess(res, result, `${this.getModelName()} created successfully`, 201);
    } catch (error) {
      console.log('Error in create:', error);
      await t.rollback();
      next(error)
    }
  };

  update = async (req: RequestWithUser, res: Response, next:NextFunction): Promise<void> => {
    const { id } = req.params;
    console.log('id', id)
    try {
      console.log('req user', req.user)
      const whereFilterRaw  = await this.applyClientFilter(req);
      console.log('whereFilterRaw', whereFilterRaw)
      const whereFilter = Object.fromEntries(
      Object.entries(whereFilterRaw).filter(([_, v]) => v !== undefined)
    );

      const options = this.getByIdOptions(id, req);

      const { include, ...restOptions } = options;

      const finalWhere = {
        [this.model.primaryKeyAttribute]: id,
        ...whereFilter,
      };

      const item = await this.model.findOne({
        where: finalWhere,
        include,
        ...restOptions,
        logging: console.log,
      });
      if (!item) {
         jsonNotFound(res, `${this.getModelName()} not found`, id);
         return;
      }
      let body = Object.fromEntries(
        Object.entries(req.body).filter(([key]) =>
          this.allowedFields.includes(key)
        )
      ) as MakeNullishOptional<T["_creationAttributes"]>;

      const unknownFields = Object.keys(req.body).filter(
        (key) => !this.allowedFields.includes(key)
      );

      if (unknownFields.length) {
         jsonBadRequest(res, `Invalid field(s): ${unknownFields.join(", ")}`);
         return;
      }

      body = await this.beforeUpdate(body, req);
      
      await item?.update(body);
       jsonSuccess(res, item, `${this.getModelName()} updated successfully`);
    } catch (error) {
      next(error)
    }
  };

  delete = async (req: RequestWithUser, res: Response, next: NextFunction): Promise<void> => {
  const { id } = req.params;

  try {
    const { role, userId } = req.user || {};
    const item = await this.model.findByPk(id);

    if (!item) {
      jsonNotFound(res, `${this.getModelName()} not found`, id);
      return ;
    }

    if (role === "customer") {
      if (item.getDataValue("userId") !== userId) {
        jsonForbidden(res, "You do not have permission to delete this resource");
        return ;
      }
    }

    if (role === "admin") {
      if (this.model.name === "User") {
        const targetRoleId = item.getDataValue("roleId");
        const roleData = await Role.findByPk(targetRoleId);

        if (roleData?.name !== "customer") {
          jsonForbidden(res, "Admin cannot delete admin/superadmin");
          return ;
        }
      }
    }
    await item.destroy();

    jsonSuccess(
      res,
      item,
      `${this.getModelName()} deleted (soft) successfully`
    );
  } catch (error) {
    console.log("Error in delete:", error);
    next(error);
  }
};

}